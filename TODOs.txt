Tasks to work on

HIGH PRIORITY
* Shells and shell management
* Server/NetInstance:
    ** AGENT_DIE functionality                              Status: Untested
    ** AGENT_SLEEP functionality
    ** AGENT_DOWNLOAD_FILE functionality
    ** AGENT_UPLOAD_FILE functionality
    ** AGENT_REVERSE_SHELL functionality                    
    ** AGENT_EXECUTE_SHELLSCRIPT functionality
* Server/Server:
    ** TASK_NEW_NETINST functionality
    ** NETINST_TERMINATE functionality
    ** Restart first NetInst on 0 active listener threads
* Increase application fault tollerance
* Manager:
    ** Backend Rework
* Bugcheck in SshTransport::fetch_tasking() on remote termination
    ** nullptr deref after SshTransport::read() and printf
    ** likely unchecked null read


MEDIUM PRIORITY
* Implement testing framework/harness
* Upgrade authentication system (database?)
* Integrate SSH keys into SSH agent and transport 

LOW PRIORITY
* Proper versioning for the server/manager applications
* General use function audit -> reduce redundant/defunct code
* Add CLI manager interface


















///////////////////// Structure notes /////////////////////////////

What doesn't work
15. WTF are we gonna do about shells?
    -> How to handle asynchronous netcomms over synchronous connection?
        * could use switch w/ file descriptors
        * maybe make backends use FDs to communicate?







New Network Frame Communication Structure:

1 byte --> OPCODE (dont think we need more than 256 OPCODES)
4 bytes --> unsigned int SIZE OF data
    -> could we make this a long (8 byte) and just use the upper byte to encode
       OPCODE so we only need to read 1 long before reading the whole data payload?

v bytes --> data


Could use a hearbeat opcode that a remote agent could send to check if there has
been an update on what anything going on





//////////////////////// OLD STUFF DOWN HERE //////////////////////////////////


















Current objectives:
    1. Design and setup MainWindow.rev_sh GUI widget
    2. Set up session.req_rvsh to task the reverse shell, and start 2 new listeners
        - One listener for the agent, and one listener for the manager's terminal session
    2a. session.req_rvsh needs to fork a new background terminal process for handling the session
    3. Work on SshTransport->init_reverse_shell
        - One design idea would be to include a third connection type for shells, and sessions that listen on the particular socket would accept multiple connections?
            * that way we could just drop a connection into a wait cycle until the other connection comes through
            * Note that this could be done with multiple listeners too (and that might be better for server-side information handling and flexibility)
        - Note: may need a moderator function that can take input from one thread and pass it to another
        - Maybe through a shared memory chunk?
    4. Incorporate agent management/information into server
        - maintain a list of awaiting agents in the server and their listening ports





Todos:

1. Rework ConnectionInstance::send_loot to only loop once through directory
2. Rework ConnectionInstance::send_loot to use built-in transport functionality
3. Rework ConnectionInstance::agent_handler to use ConnectionInstance functions instead of calling API functions directly
4. Rework Server in order to restart listening services when they end

a. Comment python code for easier maintenence
_____________________________________________________________________________________________________
Current Bugs:

1. Fix problems related to uncleared server buffers
    * Check out loot downloading

2. Infinite looping happening when consecutive module executions

3. Fix catching of empty data file

4. Fix server not overwriting default agent manifest

_____________________________________________________________________________________________________
Feature Ideas:

1. Obfuscate client hard-coded values
    * Maybe a simple XOR encrypt-decrypt?
        ** Would be easy, but would include non-encrypted data

2. Add anti-debugging things
    * Test for sandboxing/VM (timed delay, VMWare asm instructions)
        ** Resources for this:
            https://kb.vmware.com/s/article/1009458
            https://www.cyberbit.com/blog/endpoint-security/anti-vm-and-anti-sandbox-explained/

3. Add argparsing onto client
    * Maybe homebrew in order to keep dependencies low?


_____________________________________________________________________________________________________
Notes:

Check out this method for handling custom methods over multiple processes and fds
https://github.com/curesec/tools/tree/master/aesshell
